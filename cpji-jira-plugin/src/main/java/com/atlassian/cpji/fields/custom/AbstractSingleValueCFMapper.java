package com.atlassian.cpji.fields.custom;

import com.atlassian.cpji.fields.CustomFieldMappingResult;
import com.atlassian.cpji.fields.value.DefaultFieldValuesManager;
import com.atlassian.cpji.rest.model.CustomFieldBean;
import com.atlassian.jira.component.ComponentAccessor;
import com.atlassian.jira.issue.Issue;
import com.atlassian.jira.issue.IssueInputParameters;
import com.atlassian.jira.issue.fields.CustomField;
import com.atlassian.jira.issue.issuetype.IssueType;
import com.atlassian.jira.project.Project;
import com.google.common.collect.Lists;
import org.apache.log4j.Logger;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Abstract class for mapping custom fields which contain a single value.
 *
 * @param <T> the type of value stored by the custom field
 * @since v2.1
 */
public abstract class AbstractSingleValueCFMapper<T> implements CustomFieldMapper
{

    private static final Logger log = Logger.getLogger(AbstractSingleValueCFMapper.class);

    /**
     * Convert the value stored by the custom field to a String. The value will not be null.
     *
     * @param value the value given by the custom field, see {@link CustomField#getValue(com.atlassian.jira.issue.Issue)}
     * @return a String representing the value
     */
    protected abstract String convertToString(T value);

    /**
     * Format the String value for the generated by {@link #convertToString(Object)}. The given String will have been
     * generated on the source JIRA instance. On the destination instance, we may need to format the value differently,
     * e.g. if the value is a Date, each JIRA instance may have a different format for representing dates as strings.
     *
     * @param value a String representing the custom field value
     * @param customField
     * @param project
     * @param issueType
     * @return a formatted String recognisable by the current JIRA instance
     */
    protected abstract String formatString(String value, CustomField customField, Project project, IssueType issueType);

    /**
     * Determines if the given value is value for the given custom field. The value will not be null.
     *
     * @param value the custom field value, will not be null
     * @param customField
     * @param project
     * @param issueType
     * @return true if the value is valid, false if otherwise
     */
    protected abstract boolean isValidValue(String value, CustomField customField, Project project, IssueType issueType);

    @Override
    public CustomFieldBean createFieldBean(final CustomField customField, final Issue issue)
    {
        final Object value = customField.getValue(issue);
        final T typedValue = convertToGenericType(value);

        //if something will go wrong - we have empty value
        List<String> values = Collections.emptyList();

        if (typedValue != null)
        {
            try
            {
                final String stringValue = convertToString(typedValue);
                values = Lists.newArrayList(stringValue);
            }
            catch (final ClassCastException e)
            {
                log.warn(this.getClass().getName() + " cannot cast CustomField value to specified type", e);
            }
        }

        final String customFieldType = customField.getCustomFieldType().getClass().getCanonicalName();
        return new CustomFieldBean(customFieldType, customField.getName(), customField.getId(), values);
    }

    @Override
    public CustomFieldMappingResult getMappingResult(final CustomFieldBean customFieldBean, final CustomField customField, final Project project, final IssueType issueType)
    {
        final List<String> validValues;
        final List<String> invalidValues;

        final String value = getValue(customFieldBean.getValues());
        if (value == null)
        {
            validValues = Collections.emptyList();
            invalidValues = Collections.emptyList();
        }
        else if (isValidValue(value, customField, project, issueType))
        {
            validValues = Arrays.asList(value);
            invalidValues = Collections.emptyList();
        }
        else
        {
            validValues = Collections.emptyList();
            invalidValues = Arrays.asList(value);
        }

        return new CustomFieldMappingResult(validValues, invalidValues, defaultValueConfigured(project, customField, issueType));
    }

    @Override
    public void populateInputParameters(final IssueInputParameters inputParameters, final CustomFieldMappingResult mappingResult, final CustomField customField, final Project project, final IssueType issueType)
    {
        final String value = getValue(mappingResult.getValidValues());
        if (value != null)
        {
            final String formattedValue = formatString(value, customField, project, issueType);
            inputParameters.addCustomFieldValue(customField.getId(), formattedValue);
        }
    }

    private String getValue(final List<String> values)
    {
        if (values == null || values.isEmpty())
        {
            return null;
        }

        return values.get(0);
    }


    protected T convertToGenericType(final Object value)
    {
        if (value == null)
        {
            return null;
        }

        return (T) value;
    }

	/**
	 * It will return true if the mapper detects there's a default value configured in the destination server. Either the value is configured
	 * manually in project configuration or it can be detected based on JIRA configuration.
	 *
	 * @return true if we can guess the default value
	 */
	boolean defaultValueConfigured(Project project, CustomField customField, IssueType issueType)
	{
		return (getDefaultFieldValuesManager().getDefaultFieldValue(project.getKey(), customField.getId(),
				issueType.getName()) != null);
	}

	protected DefaultFieldValuesManager getDefaultFieldValuesManager() {
		return ComponentAccessor.getComponent(DefaultFieldValuesManager.class);
	}
}
